function result = qp_grad(P,q,A_ineq,b_ineq,A_eq, b_eq, l_bound, u_bound,init)
stepsize = 0.1;
Grad = P*init + q;
new = init - stepsize*Grad;
% opts = optimset('lsqlin');
% opts.Display = "none";
% opts.Diagnostics = 'off';
% opts.LargeScale ='off';
result = lsqlin(eye(length(new)),new,A_ineq,b_ineq,A_eq,b_eq,l_bound,u_bound,[],opts);


% result = init;
% max_steps = 100;
% start = 0.01;
% Grad = P*init + q;
% 
% if isempty(A_eq)
%     Aq = [];
% else
%     Aq = A_eq;
% end
% for i = 1:size(A_ineq,1)
%     if (A_ineq(i,:)*init == b_ineq(i,:))
%         Aq = [Aq;A_ineq(i,:)];
%     end
% end
% 
% for i = 1:size(l_bound,1)
%     row = zeros(1,size(l_bound,1));
%     if (init(i,:) == l_bound(i,:))
%         row(1,i) = -1;
%         Aq = [Aq;row];
%     end
% end
% 
% for i = 1:size(u_bound,1)
%    row = zeros(1,size(u_bound,1));
%    if (init(i,:) == u_bound(i,:))
%         row(1,i) = 1;
%         Aq = [Aq;row];
%    end
% end
% fin = false;
% while ~fin
%     
%     Ap = Aq'*inv(Aq*Aq')*Aq;
%     P = eye(size(Ap)) - Ap;
%     d = -P*Grad;
%     
%     if max(d ~= 0)
%         step = start;
%         x = init;
%         for i = 1:max_steps
%             test = x + step*d;
%             if ~isempty(A_ineq)
%                  check = max(A_ineq*test > b_ineq);
%             else
%                 check = false;
%             end
%             if ~isempty(A_eq)
%                 check = check | max(A_eq*test ~= b_eq);
%             end
%             if ~isempty(l_bound)
%                 check = check | max(test < l_bound-0.01);
%             end
%             if ~isempty(u_bound)
%                 check = check | max(test > u_bound);
%             end
%             if (check)
%                 %step = step/2;
%             else
%                 x = test;
%                 %step = step*2;
%             end
%         end
%         alpha1 = (x(1) - init(1))/d(1);
%         x = init;
%         minimum = 0.5*init'*P*init + q'*init;
%         steps = linspace(0,alpha1,max_steps);
%         steps(1) = [];
%         steps = [steps,alpha1];
%         result = x;
%         for i = 1:max_steps
%             test = x + steps(i)*d;
%             test_val = 0.5*test'*P*test + q'*test;
%             if (test_val < minimum)
%                 result = test;
%                 minimum =  test_val;
%             end
%         end
%         
%         fin = true;
%     else
%         lambda = -inv(Aq*Aq')*Aq*Grad;
%         lambda_ineq = lambda(size(A_eq,1)+1:end);
%         if min(lambda_ineq < 0)
%             [~,loc] = min(lambda_ineq);
%             Aq(loc+size(A_eq),:) = [];
%         else
%             result = init;
%             fin = true;
%         end
%     end
% end
end